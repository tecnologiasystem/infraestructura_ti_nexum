from __future__ import annotations

import enum
from dataclasses import dataclass
from typing import Any, Generic, Literal, TypeVar, overload
from weakref import WeakKeyDictionary

from ._core._eventloop import get_async_backend

T = TypeVar("T")
D = TypeVar("D")


async def checkpoint() -> None:
    """
    Realiza un punto de control asíncrono que verifica si la tarea ha sido cancelada
    y permite al planificador cambiar a otra tarea.

    Es más eficiente que llamar await checkpoint_if_cancelled() seguido de await cancel_shielded_checkpoint().

    Este método es importante para cooperar con el sistema de cancelación y permitir multitarea.
    """
    await get_async_backend().checkpoint()


async def checkpoint_if_cancelled() -> None:
    """
    Punto de control que solo verifica si el scope de cancelación actual fue cancelado.

    No permite cambiar a otra tarea, solo detecta cancelación.

    Usado para responder rápidamente a cancelaciones sin cambio de contexto.
    """
    await get_async_backend().checkpoint_if_cancelled()


async def cancel_shielded_checkpoint() -> None:
    """
    Punto de control que permite cambio de tarea pero protege contra cancelaciones.

    Es equivalente a ejecutar await checkpoint() dentro de un CancelScope con shield=True.

    Se usa para cooperar con el planificador sin permitir cancelaciones en ese punto.
    """
    await get_async_backend().cancel_shielded_checkpoint()


def current_token() -> object:
    """
    Obtiene el token específico del backend para el event loop actual.

    Este token permite identificar el contexto de ejecución actual y es usado para acceder a variables de contexto scoped al event loop.
    """
    return get_async_backend().current_token()


_run_vars: WeakKeyDictionary[Any, dict[str, Any]] = WeakKeyDictionary()
_token_wrappers: dict[Any, _TokenWrapper] = {}


@dataclass(frozen=True)
class _TokenWrapper:
    __slots__ = "_token", "__weakref__"
    _token: object


class _NoValueSet(enum.Enum):
    NO_VALUE_SET = enum.auto()


class RunvarToken(Generic[T]):
    """
    Token para manejo seguro del valor de una RunVar.

    Guarda referencia a la RunVar y su valor anterior, para poder revertir el valor si es necesario.
    """

    __slots__ = "_var", "_value", "_redeemed"

    def __init__(self, var: RunVar[T], value: T | Literal[_NoValueSet.NO_VALUE_SET]):
        self._var = var
        self._value: T | Literal[_NoValueSet.NO_VALUE_SET] = value
        self._redeemed = False


class RunVar(Generic[T]):
    """
    Similar a contextvars.ContextVar, pero el alcance está limitado al event loop que está ejecutando.

    Permite definir variables con valores que varían según el contexto de ejecución async actual (scoped to the running event loop).
    """

    __slots__ = "_name", "_default"

    NO_VALUE_SET: Literal[_NoValueSet.NO_VALUE_SET] = _NoValueSet.NO_VALUE_SET

    _token_wrappers: set[_TokenWrapper] = set()

    def __init__(
        self, name: str, default: T | Literal[_NoValueSet.NO_VALUE_SET] = NO_VALUE_SET
    ):
        self._name = name
        self._default = default

    @property
    def _current_vars(self) -> dict[str, T]:
        """
        Obtiene el diccionario de variables RunVar del contexto (event loop) actual.

        Usa el token actual para identificar el contexto y obtener o crear el dict.
        """
        token = current_token()
        try:
            return _run_vars[token]
        except KeyError:
            run_vars = _run_vars[token] = {}
            return run_vars

    @overload
    def get(self, default: D) -> T | D: ...

    @overload
    def get(self) -> T: ...

    def get(
        self, default: D | Literal[_NoValueSet.NO_VALUE_SET] = NO_VALUE_SET
    ) -> T | D:
        """
        Obtiene el valor actual de la RunVar para el contexto activo.

        Si no existe valor y se proporciona un default, lo retorna.

        Si no hay valor ni default, lanza LookupError.
        """
        try:
            return self._current_vars[self._name]
        except KeyError:
            if default is not RunVar.NO_VALUE_SET:
                return default
            elif self._default is not RunVar.NO_VALUE_SET:
                return self._default

        raise LookupError(
            f'Run variable "{self._name}" has no value and no default set'
        )

    def set(self, value: T) -> RunvarToken[T]:
        """
        Asigna un nuevo valor a la RunVar en el contexto actual.

        Retorna un token que puede usarse para restaurar el valor previo con reset().
        """
        current_vars = self._current_vars
        token = RunvarToken(self, current_vars.get(self._name, RunVar.NO_VALUE_SET))
        current_vars[self._name] = value
        return token

    def reset(self, token: RunvarToken[T]) -> None:
        """
        Restaura el valor previo guardado en el token para esta RunVar.

        Asegura que el token pertenece a esta variable y que no se ha usado previamente.

        Si el valor previo fue NO_VALUE_SET, elimina la variable del contexto.
        """
        if token._var is not self:
            raise ValueError("This token does not belong to this RunVar")

        if token._redeemed:
            raise ValueError("This token has already been used")

        if token._value is _NoValueSet.NO_VALUE_SET:
            try:
                del self._current_vars[self._name]
            except KeyError:
                pass
        else:
            self._current_vars[self._name] = token._value

        token._redeemed = True

    def __repr__(self) -> str:
        return f"<RunVar name={self._name!r}>"
