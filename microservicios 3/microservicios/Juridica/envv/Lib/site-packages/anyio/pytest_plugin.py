from __future__ import annotations

import socket
import sys
from collections.abc import Callable, Generator, Iterator
from contextlib import ExitStack, contextmanager
from inspect import isasyncgenfunction, iscoroutinefunction, ismethod
from typing import Any, cast

import pytest
import sniffio
from _pytest.fixtures import SubRequest
from _pytest.outcomes import Exit

from ._core._eventloop import get_all_backends, get_async_backend
from ._core._exceptions import iterate_exceptions
from .abc import TestRunner

if sys.version_info < (3, 11):
    from exceptiongroup import ExceptionGroup


# Variables globales para manejo del runner de pruebas async
_current_runner: TestRunner | None = None
_runner_stack: ExitStack | None = None
_runner_leases = 0


def extract_backend_and_options(backend: object) -> tuple[str, dict[str, Any]]:
    """
    Recibe el parámetro `backend` que puede ser un string con el nombre del backend,
    o una tupla (string, dict) con nombre y opciones.
    Retorna el nombre del backend y las opciones en dict.
    Lanza error si el parámetro no es válido.
    """
    if isinstance(backend, str):
        return backend, {}
    elif isinstance(backend, tuple) and len(backend) == 2:
        if isinstance(backend[0], str) and isinstance(backend[1], dict):
            return cast(tuple[str, dict[str, Any]], backend)

    raise TypeError("anyio_backend must be either a string or tuple of (string, dict)")


@contextmanager
def get_runner(
    backend_name: str, backend_options: dict[str, Any]
) -> Iterator[TestRunner]:
    """
    Context manager para obtener y manejar un runner de pruebas asíncronas.
    Crea el runner si no existe, y mantiene un contador de usuarios (leases).
    Cuando no quedan usuarios, cierra y libera el runner.
    """
    global _current_runner, _runner_leases, _runner_stack
    if _current_runner is None:
        asynclib = get_async_backend(backend_name)  # Obtiene backend async (e.g., asyncio)
        _runner_stack = ExitStack()  # Maneja contexto del runner
        if sniffio.current_async_library_cvar.get(None) is None:
            # Setea el backend async en sniffio si no está seteado
            token = sniffio.current_async_library_cvar.set(backend_name)
            _runner_stack.callback(sniffio.current_async_library_cvar.reset, token)

        backend_options = backend_options or {}
        # Crea y entra en el contexto del runner
        _current_runner = _runner_stack.enter_context(
            asynclib.create_test_runner(backend_options)
        )

    _runner_leases += 1  # Incrementa contador de usuarios
    try:
        yield _current_runner  # Devuelve el runner para que lo use el contexto
    finally:
        _runner_leases -= 1  # Al salir del contexto, decrementa el contador
        if not _runner_leases:
            # Si no quedan usuarios, cierra el runner y libera recursos
            assert _runner_stack is not None
            _runner_stack.close()
            _runner_stack = _current_runner = None


def pytest_configure(config: Any) -> None:
    """
    Configura pytest para agregar un marcador 'anyio' para tests async.
    """
    config.addinivalue_line(
        "markers",
        "anyio: mark the (coroutine function) test to be run asynchronously via anyio.",
    )


@pytest.hookimpl(hookwrapper=True)
def pytest_fixture_setup(fixturedef: Any, request: Any) -> Generator[Any]:
    """
    Hook para interceptar la configuración de fixtures async.
    Envuelve funciones coroutine y async generator para que se ejecuten en el runner anyio.
    """
    def wrapper(
        *args: Any, anyio_backend: Any, request: SubRequest, **kwargs: Any
    ) -> Any:
        # Rebind para métodos que sean parte de una clase de test (para que usen la instancia actual)
        if (
            request.instance
            and ismethod(func)
            and type(func.__self__) is type(request.instance)
        ):
            local_func = func.__func__.__get__(request.instance)
        else:
            local_func = func

        backend_name, backend_options = extract_backend_and_options(anyio_backend)
        if has_backend_arg:
            kwargs["anyio_backend"] = anyio_backend

        if has_request_arg:
            kwargs["request"] = request

        # Ejecuta fixture async dentro del runner
        with get_runner(backend_name, backend_options) as runner:
            if isasyncgenfunction(local_func):
                yield from runner.run_asyncgen_fixture(local_func, kwargs)
            else:
                yield runner.run_fixture(local_func, kwargs)

    func = fixturedef.func
    # Solo afecta fixtures async que usen anyio_backend
    if isasyncgenfunction(func) or iscoroutinefunction(func):
        if "anyio_backend" in request.fixturenames:
            fixturedef.func = wrapper
            original_argname = fixturedef.argnames

            # Añade argumentos si no existen
            if not (has_backend_arg := "anyio_backend" in fixturedef.argnames):
                fixturedef.argnames += ("anyio_backend",)

            if not (has_request_arg := "request" in fixturedef.argnames):
                fixturedef.argnames += ("request",)

            try:
                return (yield)
            finally:
                # Restaura la función y argumentos originales
                fixturedef.func = func
                fixturedef.argnames = original_argname

    return (yield)


@pytest.hookimpl(tryfirst=True)
def pytest_pycollect_makeitem(collector: Any, name: Any, obj: Any) -> None:
    """
    Hook para detectar funciones de test que son coroutines y marcadas con 'anyio',
    para ejecutar tests async con el fixture anyio_backend.
    """
    if collector.istestfunction(obj, name):
        inner_func = obj.hypothesis.inner_test if hasattr(obj, "hypothesis") else obj
        if iscoroutinefunction(inner_func):
            marker = collector.get_closest_marker("anyio")
            own_markers = getattr(obj, "pytestmark", ())
            if marker or any(marker.name == "anyio" for marker in own_markers):
                pytest.mark.usefixtures("anyio_backend")(obj)


@pytest.hookimpl(tryfirst=True)
def pytest_pyfunc_call(pyfuncitem: Any) -> bool | None:
    """
    Hook para ejecutar funciones de test async dentro del runner anyio.

    Maneja integración con hypothesis y captura de excepciones agrupadas.
    """
    def run_with_hypothesis(**kwargs: Any) -> None:
        with get_runner(backend_name, backend_options) as runner:
            runner.run_test(original_func, kwargs)

    backend = pyfuncitem.funcargs.get("anyio_backend")
    if backend:
        backend_name, backend_options = extract_backend_and_options(backend)

        if hasattr(pyfuncitem.obj, "hypothesis"):
            original_func = pyfuncitem.obj.hypothesis.inner_test
            if original_func.__qualname__ != run_with_hypothesis.__qualname__:
                if iscoroutinefunction(original_func):
                    pyfuncitem.obj.hypothesis.inner_test = run_with_hypothesis

            return None

        if iscoroutinefunction(pyfuncitem.obj):
            funcargs = pyfuncitem.funcargs
            testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
            with get_runner(backend_name, backend_options) as runner:
                try:
                    runner.run_test(pyfuncitem.obj, testargs)
                except ExceptionGroup as excgrp:
                    for exc in iterate_exceptions(excgrp):
                        if isinstance(exc, (Exit, KeyboardInterrupt, SystemExit)):
                            raise exc from excgrp

                    raise

            return True

    return None


@pytest.fixture(scope="module", params=get_all_backends())
def anyio_backend(request: Any) -> Any:
    """
    Fixture parametrizado para ejecutar tests con todos los backends disponibles en anyio.
    """
    return request.param


@pytest.fixture
def anyio_backend_name(anyio_backend: Any) -> str:
    """
    Fixture que devuelve solo el nombre del backend actual para facilitar su uso.
    """
    if isinstance(anyio_backend, str):
        return anyio_backend
    else:
        return anyio_backend[0]


@pytest.fixture
def anyio_backend_options(anyio_backend: Any) -> dict[str, Any]:
    """
    Fixture que devuelve el diccionario de opciones del backend, o dict vacío si no tiene.
    """
    if isinstance(anyio_backend, str):
        return {}
    else:
        return anyio_backend[1]


class FreePortFactory:
    """
    Clase que genera puertos libres TCP o UDP para tests.

    Controla para que no se repitan puertos en la sesión.

    Uso:
      - Crear instancia con tipo socket (TCP o UDP)
      - Llamar la instancia para obtener puerto libre
    """

    def __init__(self, kind: socket.SocketKind) -> None:
        self._kind = kind
        self._generated = set[int]()  # Guarda puertos ya entregados

    @property
    def kind(self) -> socket.SocketKind:
        """
        Retorna el tipo de socket (TCP o UDP) que esta fábrica genera.
        """
        return self._kind

    def __call__(self, family: socket.AddressFamily | None = None) -> int:
        """
        Busca un puerto libre no asignado, para la familia de direcciones dada (IPv4 o IPv6).

        Si no se especifica familia, prueba IPv4 e IPv6.

        Retorna un número de puerto disponible que no se haya dado antes.
        """
        if family is not None:
            families = [family]
        else:
            families = [socket.AF_INET]
            if socket.has_ipv6:
                families.append(socket.AF_INET6)

        while True:
            port = 0
            with ExitStack() as stack:
                for family in families:
                    sock = stack.enter_context(socket.socket(family, self._kind))
                    addr = "::1" if family == socket.AF_INET6 else "127.0.0.1"
                    try:
                        sock.bind((addr, port))
                    except OSError:
                        break

                    if not port:
                        port = sock.getsockname()[1]
                else:
                    if port not in self._generated:
                        self._generated.add(port)
                        return port


@pytest.fixture(scope="session")
def free_tcp_port_factory() -> FreePortFactory:
    """
    Fixture para obtener una fábrica de puertos TCP libres para toda la sesión de tests.
    """
    return FreePortFactory(socket.SOCK_STREAM)


@pytest.fixture(scope="session")
def free_udp_port_factory() -> FreePortFactory:
    """
    Fixture para obtener una fábrica de puertos UDP libres para toda la sesión de tests.
    """
    return FreePortFactory(socket.SOCK_DGRAM)


@pytest.fixture
def free_tcp_port(free_tcp_port_factory: Callable[[], int]) -> int:
    """
    Fixture para obtener un puerto TCP libre para un test específico.
    """
    return free_tcp_port_factory()


@pytest.fixture
def free_udp_port(free_udp_port_factory: Callable[[], int]) -> int:
    """
    Fixture para obtener un puerto UDP libre para un test específico.
    """
    return free_udp_port_factory()
